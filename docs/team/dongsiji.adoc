= Dong SiJi - Project Portfolio
:site-section: AboutUs
:imagesDir: ../images
:stylesDir: ../stylesheets
:sectnums:

= PROJECT: Heart²

The purpose of this document is to document the contribution that I have made in the project: *_Heart²_*
as a student undertaking the module CS2103T under NUS School of Computing.

*_Heart²_* github link: https://github.com/CS2103-AY1819S1-F10-3/main

---

== Introduction

*_Heart²_* is a desktop software aiming to make the job of wedding planning agencies simpler.
It provides simple yet powerful features to efficiently manage clients' and agency companies' profiles.
Users can find suitable wedding service providers for clients using just a few keystrokes with our enterprise featureset.

The project is written in Java and has about 10 thousand lines of code. The user interacts with the application mainly using a Command Line Interface (CLI),
and it also has a Graphic User Interface (GUI) created with JavaFX for users who are not so adept with the keyboard.

== Summary of contributions

|===
|Below is a summary of the contributions that I have made to the project.
|===

=== Major Enhancement
* *Major enhancement*: Revamping the `list` command.
* *Functionality*: The user is able to use this command to list all clients or service providers and they are also able to use the command to search through clients and service providers by providing the relevant keywords that they want to search for.
* *Justification*: By having both the searching and listing functionality in one command the user will have less commands to familiarise with and it increases the ease of use of the application.
* *Highlights*: To revamp the list command, I had to have a deep understanding of how the commands work and revamp the parser for the command first. I also had to change how some of the information was stored in the application, so that the relevant information could be obtained when necessary.
* *Functional Code Contributed*: link:dongsijiContributedCode.adoc[all code]
* *Test Code Contributed*: link:https://github.com/CS2103-AY1819S1-F10-3/main/pull/150[all tests]

=== Minor Enhancement
* *Minor enhancement*: Enable `undo` and `redo` commands to show the relevant list.
* *Functionality*: The list shown to the user after executing the `undo` and `redo` commands will be the list of clients or service providers that was changed through the command.
* *Justification*: To allow the user to be able to see what was changed clearly.
* *Functional Code Contributed*: link:https://github.com/CS2103-AY1819S1-F10-3/main/pull/188[all code]
* *Test Code Contributed*: link:https://github.com/CS2103-AY1819S1-F10-3/main/pull/188[all tests]

=== Other Contributions

* *Community*:
** Reported bugs and provide suggestions to other team members' code: https://github.com/CS2103-AY1819S1-F10-3/main/issues/198[1], https://github.com/CS2103-AY1819S1-F10-3/main/issues/134[2], https://github.com/CS2103-AY1819S1-F10-3/main/issues/133[3]

* *Documentation*:
** Wrote the link:https://github.com/CS2103-AY1819S1-F10-3/main/blob/master/docs/AboutUs.adoc[about us] documentation.
** Contributed to the User Guide and Developer Guide for this project. See below for more details.

== Contributions to the User Guide

|===
|Below are sections I contributed to the User Guide. They showcase my ability to write documentation targeting end-users.
|===

=== Listing and searching for clients

You can view clients in the database as a list using the `client list` command.

If you do not key in any parameters, it will list out all the clients,
otherwise it will list all clients matching all of the search parameters you provided.

Format: `client list [n/FULL_NAME] [p/PHONE_NUMBER] [e/EMAIL_ADDRESS] [a/HOME_ADDRESS] [t/TAG]...`

[cols="^,<5a", frame=none]
|=====
|image:exampleimage.png[width="64", role="center"]
|* `client list`
 * `client list n/John Doe`
|=====

{empty} +

=== Listing and searching for service providers

You can view service providers in the database as a list using the `serviceprovider list` command.

If you do not key in any parameters, it will list out all the service providers,
otherwise it will list all service providers matching all of the search parameters you provided.

Format: `serviceprovider list [n/FULL_NAME] [p/PHONE_NUMBER] [e/EMAIL_ADDRESS] [a/HOME_ADDRESS] [t/TAG]...`

[cols="^,<5a", frame=none]
|=====
|image:exampleimage.png[width="64", role="center"]
|* `serviceprovider list`
 * `serviceprovider list n/John Doe`
|=====

{empty} +

=== Undo the previous command: 'undo'

Undo the commands that you have entered in chronological order.

Format: `undo`

[NOTE]
====
The application will only undo commands that modifies the list of contacts: `add`, `update`, `delete`, `clear`
====
[NOTE]
====
The application will show either the client list or service
provider list corresponding to the command that was undone.
====

{empty} +

=== Redo the commands undone: 'redo'

Redo the commands that you have undone by undo in chronological order.

Format: `redo`

[NOTE]
====
Commands that have been undone will be reset upon a `clear` command.
====
[NOTE]
====
The application will show either the client list or service
provider list corresponding to the command that was redone.
====

== Contributions to the Developer Guide

|===
|Below are sections I contributed to the Developer Guide. They showcase my ability to write technical documentation and the technical depth of my contributions to the project.
|===

=== Aspect: What it shows after undo/redo command successfully executes

* *Alternative 1 (current choice):* Shows the list that was changed due to the undo/redo command.
** Pros: Easy for the user to identify what was changed, whether a client or service provider was modified.
** Cons: It switches the list out of the current filter and the user have to re-type the list command if he wants to filter the list.
* *Alternative 2:* Keeps showing what was shown before the command was executed.
** Pros: Easy to implement.
** Cons: Hard for the user to identify what was changed in the addressbook.
* *Alternative 3:* Show what was changed, before and after.
** Pros: User can easily tell what was changed.
** Cons: Hard to implement, need to have an additional UI components to show what was changed and need additional components to store the list before it was changed.

{empty} +

=== List Feature
*_Heart²_* allows you view all the clients or the service providers with a simple command: `list`.

When listing contacts, you would have to specify whether the contact is a client or a service provider
by prefixing it to list:

* `client list`
* `serviceprovider list`

Below shows an example of how listing all clients works:

._The UI showing listing all clients._
image::ListAllClients.png[width="800"]

{empty} +

Furthermore, you are also able to add keywords after the list to do filtering, and each keyword is specified to
belong to a category and only contacts which contains all of the keywords in their respective categories will be shown.

[NOTE]
====
Categories include:

* `n/` NAME
* `p/` PHONE_NUMBER
* `e/` EMAIL_ADDRESS
* `a/` ADDRESS
* `t/` TAGS
====

Below shows an example of how list filtering works:

._The UI showing list filtering._
image::ListClientsWithKeywords.png[width="800"]

{empty} +

==== Implementation

The keywords from the command to be used for filtering is parsed by the `ListCommandParser` and passed to a `Predicate`
that is implemented as `ContactContainsKeywordsPredicate`.

We then use a `FilteredList` and pass the combination of 2 `Predicates` into it, one to filter the type of contact,
clients or service providers and the other is to filter by keywords.
// TODO: ADD UML DIAGRAM

{empty} +

==== Design considerations

[none]
==== Aspect 1: Substring Matching or Word Matching
* *Alternative 1 (current choice):* Substring matching.
** Pros: Users would be able to view a wider range of results that matches the substring they have given. Easier to use.
** Cons: Irrelevant results might not be filtered away if they contain the substring.
* *Alternative 2:* Word matching.
** Pros: Guarantees that no irrelevant results are shown.
** Cons: Relevant results that have a small difference in the wording will be filtered away and not shown.

[none]
==== Aspect 2: Categorised or Non-categorised keywords
* *Alternative 1 (current choice):* Categorised keywords.
** Pros: Users are able to specify which keywords they want to search for in which category.
Gives better control over the searching.
** Cons: Users have to follow a specific format to type the keywords.
* *Alternative 2:* Non-categorised keywords.
** Pros: User can type in the keywords in any order they want. Easier to use.
** Cons: Irrelevant results that contains the keywords will be shown.

[none]
==== Aspect 3: All Match or Any Match
* *Alternative 1 (current choice):* All match.
** Pros: Users can specify what they want to search for and filter out all irrelevant results.
** Cons: Users are not able to search for multiple things, when they only require one of them to match.
* *Alternative 2:* Any match.
** Pros: Users are able to obtain a wider search result. Easier to use.
** Cons: Irrelevant results that contains only one or a few keywords will be shown as well.

{empty} +

=== Use case: List all the Clients or Service Providers

*MSS*

1.  User enters the list command and requests to view either all the Clients, or all the Service Providers.
2.  System returns either a list with all the Clients' information, or all the Service Providers' information.
+
Use case ends.

*Extensions*

[none]
* 2a. There is no Client or no Service Provider available
+
[none]
** 2a1. System returns an empty list.

+
Use case ends.

{empty} +

=== Use case: Filter and show Client’s or Service Provider’s info according to the filter

*MSS*

1.  User enters the list command and requests to view either Client’s or Service Provider’s information with some
keywords provided indicated by prefixes.
2.  The System displays a list of Clients or Service Providers whose information matches what was provided.
+
Use case ends.

*Extensions*

[none]
* 1a. User enters a prefix that does not exist.
+
[none]
** 1a1. System prompts the User the correct format of the command and prefixes that can be used.

* 1b. User enters an empty prefix.
+
[none]
** 1b1. System prompts the User the correct format of the command and prefixes that can be used.

+
Use case ends.
